#!/usr/bin/python3
# ugrep: find unicode characters based on their names or number.
# 	 Essentially grep for the Unicode table.

# PREREQUISITE: 
#
# * You'll need a copy of UnicodeData.txt installed. 
#   On Debian GNU/Linux, this can be done by `apt install unicode-data`.
#   Or, you can download it by hand from the Unicode Consortium and place
#   it in `~/.local/share/unicode/UnicodeData.txt`.

# ADDED FUNCTIONALITY: 
#
# * If you have FontConfig installed, then you can use -l to see which
#   fonts contain a certain character.
#
# * If you have ImageMagick installed and your terminal can display
#   sixels, then -l will also show a rendering of the character in
#   each font.


# Fun things to try:

# ugrep alchemical 
# ugrep ornament
# ugrep bullet
# ugrep 'vine|bud'
# ugrep vai
# ugrep heavy
# ugrep drawing
# ugrep 2300..ff

# GPL â‰¥3 (see LICENSE file)
# B9 September 2018 â€“ October 2021

debug=False

from re import *
from sys import argv, stderr
from os.path import expanduser, expandvars, basename
from os import isatty
from subprocess import getoutput, run
from posix import write
import termios
import argparse

def usage():
    print("""\
ugrep: find unicode characters based on their names or codepoints
Usage: 
    ugrep [-wlx] [-ll] [-L n] <character> | <codepoint ...> | <character name>
    ugrep -c <character string ...>

    	-w:	matches only whole words, e.g., ugrep -w pi
    	-c:	show each character in a string, e.g., ugrep -c "(ï¾Ÿâˆ€ï¾Ÿ)"
    	-l:	list installed fonts that include matching characters
       -ll:	like -l, but also includes style variants (bold, italic,...) 	
  -L scale:	scale font examples for -l; useful range 2 to 8
	-x:	show typical usage examples

           <character> A single character, e.g.:  ugrep â˜™
           <codepoint> One or more hexadecimal unicode character numbers, 
		       optionally prefixed by "U+" or "0x".e.g.: ugrep U+1F639
    		       Ranges are allowed with two dots: ugrep 23b0..f
      <character name> A Unicode name (as a regex), e.g.: ugrep alchemical
    <character string> One or more characters. e.g.: ugrep -c "( Í¡Â° ÍœÊ– Í¡Â°)"

    Try 'ugrep --examples' to see typical usage examples.
"""
    )

def examples():
    print("""\
# You can search by character name.
    $ ugrep heart
    â˜™	U+2619	REVERSED ROTATED FLORAL HEART BULLET
    â£	U+2763	HEAVY HEART EXCLAMATION MARK ORNAMENT
    â¤	U+2764	HEAVY BLACK HEART
    [ ... examples truncated for brevity ... ]
    ðŸ˜»	U+1F63B	SMILING CAT FACE WITH HEART-SHAPED EYES

# Or, you can search by pasting in a specific character.
    $ ugrep âœ¿
    âœ¿       U+273F  BLACK FLORETTE

# Or, you can search by code point.
    $ ugrep 273a
    âœº       U+273A  SIXTEEN POINTED ASTERISK

# By default, words match anywhere.
    $ ugrep clos brac			# Equivalent to "clos.*brac"
    ]       U+005D  RIGHT SQUARE BRACKET (closing square bracket)
    }       U+007D  RIGHT CURLY BRACKET (closing curly bracket)
    ã€‰      U+3009  RIGHT ANGLE BRACKET (closing angle bracket)

# Use -w to match only whole words.
    $ ugrep -w "R"			# Equivalent to "\\bR\\b"
    R	U+0052  LATIN CAPITAL LETTER R
    â„›	U+211B  SCRIPT CAPITAL R (Script r)
    â„œ	U+211C  BLACK-LETTER CAPITAL R (Black-letter r)
    â„	U+211D  DOUBLE-STRUCK CAPITAL R (Double-struck r)

# Use -c to display info for each character in a string.
    $ ugrep -c "á••( á› )á•—"
    á••	U+1555	CANADIAN SYLLABICS FI
    (	U+0028	LEFT PARENTHESIS (opening parenthesis)
    á›	U+141B	CANADIAN SYLLABICS NASKAPI WAA
    )	U+0029	RIGHT PARENTHESIS (closing parenthesis)
    á•—	U+1557	CANADIAN SYLLABICS FO

# ugrep finds aliases (in parens)
    $ ugrep backslash
    \	U+005C	REVERSE SOLIDUS (backslash)

# Regex ^ and $ work, mostly
    $ ugrep ^x				
    âŠ»	U+22BB	XOR
    âŒ§	U+2327	X IN A RECTANGLE BOX (clear key)

# Use -l to see which fonts are installed that can render a certain character
    $ ugrep -l math left tortoise
    âŸ¬    U+27EC  MATHEMATICAL LEFT WHITE TORTOISE SHELL BRACKET
                 Symbola 
                 Unifont 

# Use -L n to scale the font examples n-times larger; implies -l
    $ ugrep -L2 antimony
    [ Cannot show example here ]

# Show every single Unicode character.
    $ ugrep '.?'  |  less"""
    )


# Main
def main():
    global argv, args, debug

    # Load the Unicode Data into the global ucd variable.
    loaducd()
    
    if len(argv) == 1:
        usage()                 # ArgParse's usage is ugly, use our own.
        exit(1)

    if argv[1]=='-h' or argv[1]=='--help':
        usage()
        exit(0)

    if argv[1]=='-x' or argv[1]=='--examples' or argv[1]=='--example':
        examples()
        exit(0)

    parser = argparse.ArgumentParser(
        description='find Unicode characters by name, number, or example.')
    parser.add_argument(
        'characters', metavar='Character Name | Codepoint | Character', 
        nargs='+', type=str,
        help='which character to show specified by name, codepoint or literal example')
    parser.add_argument('-w', '--word-regexp', action="store_true",
        help='matches only whole words, e.g., ugrep -w pi')
    parser.add_argument('-c', '--char-by-char', action="store_true",
        help='show each character in a string, e.g., ugrep -c "(ï¾Ÿâˆ€ï¾Ÿ)"')
    parser.add_argument('-l', '--list-fonts', action="store_true",
        help='list fonts that include a glyph for a given character')
    parser.add_argument('-ll', '--list-fonts-long', action="store_true",
        help='list all fonts, including variants like italic, bold, etc.')
    # XXX Argh. argparse gives an error on 'ugrep -L foo' but works for 'ugrep foo -L'.
    parser.add_argument('-L', '--list-fonts-scale', metavar='scaling', dest='fonts_scale',
                        nargs='?', const=2, default=None, type=float,
        help='list fonts, scaling the characters to be from 2 to 8x larger')
    parser.add_argument('--never-double-size', action="store_true",
        help="Don't use double-size terminal text even when font scale >= 2")
    parser.add_argument('-x', '--examples',  action="store_true",
        help='show example usage')
    parser.add_argument('--debug', action="store_true", help='internal debugging')

    args = parser.parse_args()

    # -ll (list_fonts_long) same as -l but shows all font variants
    if args.list_fonts_long:
        args.list_fonts = True

    # -l (list fonts), defaults to a scaling of 1x
    if args.list_fonts and not args.fonts_scale:
        args.fonts_scale = 1

    # if -L is like -l (list fonts), but with larger images.
    if args.fonts_scale:
        args.list_fonts = True;

    if args.debug: debug=True

    # If -w, then wrap each argument with \b (regexp word breaks)
    if args.word_regexp:
        args.characters = [ "\\b"+s+"\\b" for s in args.characters ]

    # Is it -c followed by a string of characters?
    if args.char_by_char:
        # For each string s, look up each character in the string.
        for s in args.characters:
            for i in range(len(s)):
                for j in range(0,len(s[i])):
                    showonecharacter( hex(ord(s[i][j])) )
            if s is not args.characters[-1]:
                print("")       # Space between words, if multiple args 
        exit(0)

    # Is it a single character? Then only show that one character.
    if  len(args.characters)==1 and len(args.characters[0])==1:
        showonecharacter( hex(ord(args.characters[0][0])) )
        exit(0)

    # Do range expansion on argv. (e.g., 2301..f)
    args.characters = rangeexpansion(args.characters)

    # Is first arg a hexadecimal number? E.g., 26A0, 0xdeadbeef, U+FACE
    # Then *also* look up that code point.
    if match(r"(?i)^(U\+?|0x)?[0-9A-F]+$", args.characters[0]):
        # Loop to allow people to do things like "ugrep 23b{0..9}"
        for arg in args.characters:
            if match(r"(?i)^(U\+?|0x)?[0-9A-F]+$", arg):
                showonecharacter(arg)
            else:
                break

    # Now, look up the entire argv[] as a character name or alias. 
    s=makeregexcharname(args.characters)
    printmatches(s)


def showonecharacter(c):
    s=makeregexcodepoint(c)
    compileit(s)
    printmatches(s)
              
def compileit(s):
    "Compile the regular expresion in s, or die trying."
    global ucd, args

    if debug:
        debugprint(s)
        m=search(s,ucd)
        if not m: debugprint("Uncompiled, definitely not in ucd")

    try:
        s=compile(s)
    except error as e:
        err("Error parsing regex: '%s'" % ".*".join(args.characters))
        err(e)
        exit(3)


def isprint(c):
    # Given a category 'c', return True if it is printable.
    # We presume the only non-printable category is 'C' (control).
    # However, technically, much of category 'Z' (spaces) is non-printable.

    # Side note: Python is silly and regex clauses that match an empty
    # string are set to None instead of ''. That's why we doublecheck
    # that category is not None.
    return c and not c.startswith('C')

def iscombining(c):
    # Given a category 'c', return True if it is a combining character.
    # We presume all combining characters are in category 'M' and vice-versa.
    if debug:
        debugprint ("Category is <" + str(c) + ">")  

    return c and c.startswith('M')

def printmatches(s):
    category=""
    for m in finditer(s, ucd):
        if m:
            print("   ", end='') 	# Indent for MacOS
            g=m.groupdict()
            debugprint(g)
            if g["hex"] == None: g["hex"]=g["hextwo"]
            if g["name"] == None: g["name"]=g["desctwo"]
            category = g["category"] if g["category"] else g["categorytwo"]
            if g["alias"] == None: g["alias"]=g["aliastwo"]
            c=chr(int(g["hex"], 16))
            if not isprint(category): c="\ufffd" # "Replacement Character"
            if iscombining(category): print('\u25cc', end='') # "Dotted circle"
            print(c, end='\t')
            print ("U+" + g["hex"], end='\t')
            print(g["name"], end='')
            if (len(g["alias"]) and isdifferent(g["name"], g["alias"])):
                print (" (" + g["alias"].lower() + ")", end='')
            print("", flush=True)
            # If -l, show list of installed fonts which contain the glyph.
            if args.list_fonts:  show_fonts( g["hex"], category )


def show_fonts(x, category):
    """Given a hexadecimal string representing a Unicode code point, 
       list every installed font that defines a glyph at that code point."""
    
    try: fonts = getoutput("fc-list -f '%{family[0]}\t%{style[0]}\t%{file}\n' :charset=" + x + " | sort -u")
    except FileNotFoundError: print(""); return 	# No FontConfig
    except KeyboardInterrupt: exit(1) 			# Exit on ^C

    
    #   debugprint(fonts)		# List of every matching font.
    
    oldfam=""
    for f in fonts.splitlines():
        try: (family, style, filename) = f.split('\t')
        except: continue

        # Don't print the style if it is just "Regular"
        if style == "Regular" or style == "Roman":
            style = ""

        # If we're not doing a long listing, then skip variant styles
        if not args.list_fonts_long:
            if style != "": continue

        # Don't print same font twice (e.g., if installed in more than one
        # location or if there are multiple point sizes of a bitmap font).
        famstr="%(family)s %(style)s\r" % locals()
        if (famstr == oldfam): continue
        oldfam=famstr; oldstyle=style
        
        # Text positioning is hairy due to variable text and font size
        if args.fonts_scale <2: 	# The usual case:
            double_size=False
        else:                           # Alternately, with double size text: 
            double_size=True

        # Some terminals cannot handle double-size text
        if args.never_double_size:
            double_size=False

        if not double_size:
            famstr = '\t\t' + famstr	# 	Two tabs, sixteen spaces
        else:
            famstr = '\t' + famstr      # 	One double-size tab

        if isatty(1):
            # Writing to a screen? Truncate text if it would wrap.
            (rows, cols) = get_rows_cols()
            if double_size: cols = int(cols/2)
            if len(famstr.expandtabs()) > cols:
                famstr = famstr.expandtabs()[:cols]

        if sixel_capable(): 
            # If terminal can show sixel graphics, do the following:
            # 1. If fonts_scale >=2, double the size of the text of the fontname
            # 2. Position the font name based on the fontscale
            # 3. Render a sixel image of the glyph in the font

            esc=chr(0x1b)
            previous_line = esc + '[A' 	# XXX ought to use terminfo CUU

            # Escape sequence to print double size text (DECDHL)
            if double_size:
                famstr = esc + '#3' + famstr + '\n' \
                    + esc + '#4' + famstr + previous_line

            # Align text lower for 4x, 8x sized font glyphs
            if double_size and args.fonts_scale >= 4:
                famstr = '\n' + famstr + previous_line
            if double_size and args.fonts_scale >=8:
                famstr = '\n' + famstr + previous_line

        print(famstr, end='')

        if not sixel_capable():
            print("")           # stdout is not a tty, so  send a newline

	# If stdout is a terminal, show the glyph as sixels
        if sixel_capable():
            (background, foreground) = get_term_colors()
            (width, height) = get_cell_size()   # Character cell font size
            height = args.fonts_scale * height  # Increase size of font (maybe).
            if not double_size:
                width=(16-1)*width 	# Leave one space before fontname
            else:
                width=(16-2)*width  	# Leave one double-wide space
            debugprint("Font scaling factor: %g" % (args.fonts_scale))
            debugprint("Font canvas size: %g x %g" % (width, height))

            codepoint=chr(int(x,16))

            # If it's a combining character, add a dotted circle to combine with
            if iscombining(category): codepoint='\u25cc'+codepoint

            command=[ "convert",
                      "-size",
                      "%(width)sx%(height)s" % locals(),
                      "xc:" + "%(background)s" % locals(),
                      "-fill", "%(foreground)s" % locals(),
                      "(", 
                      "-background", "none",
                      "-font", "%(filename)s" % locals(),
                      "label:" + codepoint,
                      "-trim",
                      ")",
                      "-gravity", "east",
                      "-compose", "over",
                      "-composite",
                      "+dither",  
                      "-colors", "4", 	# Faster sixels by reducing colors
                      "sixel:-" ]
            debugprint(command)

            try: output=run(command, capture_output=True)
            except FileNotFoundError: print(""); continue 	# No ImageMagick
            except KeyboardInterrupt: exit(1)                   # Exit on ^C
            except ValueError: print(""); continue          # Can't handle NULL

            if output.returncode != 0:
                # Oops, font did not render.
                if double_size: print("")
                print("", flush=True)
                continue

            # Workaround ImageMagick bug by deleting graphics newline (-) at end
            output.stdout.replace(b'-\x1b\\', b'\x1b\\') 

            print("", flush=True, end='')   # Send any pending output to stdout

            try: write(1, output.stdout) 	# Print raw bytes
            except KeyboardInterrupt:		# Catch ^C
                exit(1)                         # Sixels stopped by cleanup()

def sixel_capable():
    # Return true if the terminal can show sixel graphics

    # If stdin or stdout is not a terminal, don't send sixels
    if not isatty(0) or not isatty(1):
        return False

    # XXXX TODO: check DA to see if "4" (sixels) are supported

    return True

def get_rows_cols():
    # Return number of (rows, columns) in current terminal window
    # First, try termios. It's simple but doesn't work everywhere.
    import array, fcntl, termios
    buf = array.array('H', [0, 0, 0, 0])
    if isatty(0):
        fcntl.ioctl(0, termios.TIOCGWINSZ, buf)
    (rows, cols, x, y) = buf;
    if rows==0: rows=24
    if cols==0: cols=80
    return (rows,cols)

def get_cell_size():
    # Inquire from the terminal what its character cell size is.
    # Returns a tuple (width, height) in pixels. 

    # First, try termios. It's simple but doesn't work everywhere.
    import array, fcntl, termios
    buf = array.array('H', [0, 0, 0, 0])
    if isatty(0):
        fcntl.ioctl(0, termios.TIOCGWINSZ, buf)

    # Beware of the stupid output order: y x x y.   --Egmont Koblinger
    (rows, cols, x, y) = buf;
    if rows==0: rows=24
    if cols==0: cols=80

    # VT340 on serial line has x and y set to zero.
    if x==0: x=800
    if y==0: y=480

    from math import floor

    debugprint("rows: %(rows)s\tcols: %(cols)s\tx: %(x)s\ty: %(y)s" % locals())
    debugprint("charcell w: %d\th: %d" % (floor(x/cols), floor(y/rows) ))
    return( floor(x/cols), floor(y/rows) )

def get_term_colors():
    # XXX not implemented yet
    # Inquire from the terminal what its character cell size is.
    # Returns a tuple (background, foreground) in pixels. 
    # fg = read -r -p $'\033]10;?\007' -d$'\007'
    # bg = read -r -p $'\033]11;?\007' -d$'\007'
    return ("gray10","gray90")

def print_double_size(famstr):
    esc=chr(0x1b)
    (rows, cols) = get_rows_cols()
    if len(famstr.expandtabs()) > int(cols/2):
        famstr = famstr.expandtabs()[:int(cols/2)]
    print(esc + '#3' + famstr)         # Top half double-height & width
    print(esc + '#4' + famstr, end='') # Bottom half
    print('\r' + esc + '[A', end='');  # Up 1 line for drawing sixels

    # Note: Should use terminfo for this since VT100 and VT340 differ.

def isdifferent(a, b):
    """Given two strings A & B, determine if B is different enough from A
       that we don't need to print it as well. "Enough" means "adds
       significant new information". For example, the following would
       return False:
    
       "LATIN CAPITAL LETTER A WITH GRAVE", "LATIN CAPITAL LETTER A GRAVE"

       Note that order matters. For example,

       "BROKEN BAR", "BROKEN VERTICAL BAR" 	Should return True
       "BROKEN VERTICAL BAR", "BROKEN BAR" 	Should return False
    """
    a=a.upper()
    b=b.upper()

    if a == b:
        return False
    if a == b.replace(" DIGIT ", " "):
        return False
    if a == b.replace("FORMS ", "BOX DRAWINGS "):
        return False
    if a == b.replace("GRAPHIC ", "SYMBOL "):
        return False
    if a == b.replace("GLYPH ", "PRESENTATION FORM "):
        return False
    if a == b.replace("CENTER", "CENTRE"):
        return False
    if a == b.replace("CENTERED", "CENTRED"):
        return False
    if a == b.replace("SQUARED ", "SQUARE "):
        return False

    b=b.replace(" ", ".*")
    try:
        m=search(b, a)
        if m:
            return False
        else:
            return True
    except:
        # regex should never fail, but if it does, we don't care.
        return True


    # if a.replace("WARDS ", " ") == b:
    #     return False
    # if a.replace("S ", " ") == b:
    #     return False
    # if a.rstrip("S") == b:
    #     return False
    
    return True

def loaducd():
    "Find the UnicodeData.txt file and load it up into ucd global variable."

    global ucd
    ucd=None
    ucdplaces=( "/usr/local/share/unicode/UnicodeData.txt",
                "/usr/share/unicode/UnicodeData.txt",
                "~/.local/share/unicode/UnicodeData.txt",
                "UnicodeData.txt" )
    for f in ucdplaces:
        f=expanduser(expandvars(f)) 		# Python's open() is silly
        try:
            ucd=open(f).read()
            debugprint("Found data file at " + f)
        except:
            continue

    # Sanity check: did we find the UnicodeData.txt file?
    if ucd == None:
        eprint("""\
    Could not find UnicodeData.txt in:

%s
    On most GNU/Linux systems your package manager can install it easily.
    For example:  apt install unicode-data.

    Alternately, you can grab it via wget like so:

        mkdir -p ~/.local/share/unicode
	cd ~/.local/share/unicode
        wget ftp://ftp.unicode.org/Public/UNIDATA/UnicodeData.txt
""" %
               ("".join(["    " + s + "\n" for s in ucdplaces])))
        exit(2)

    if debug:
        debugprint("Number of Unicode chars: %d" % len(ucd.splitlines()))

    return ucd


def makeregexcharname(words):
    "Create a regular expression to search for a character name"

    # Format of ucd: each character is on a separate line.
    # Each line is fifteen columns separated by semicolons.
    # We only care about columns 1, 2, 3 and 11
    #      1: Code value
    #      2: Character name
    #      3: General category
    #     11: ISO 10646 comment field (usually an alias)
    #
    # For example:
    #     002F;SOLIDUS;Po;0;CS;;;;;N;SLASH;;;;
    #
    # See Tech Report 44 for more details.
    #
    # XXX Todo: maybe look up in table of confusable entities.

    # combine and quote the command line arguments so we can use them in
    # verbose regex. Also, allow the user to use ^ and $, just like in awk
    # to refer to the beginning and end of the field instead of line.
    words=["("+x+")" for x in words]       # wrap in parens to fix alternation
    arghs=".*".join(words)                 # search terms can have junk between
    arghs=sub(r"(\s)", r"\\\1", arghs)     # quote whitespace for verbose regex
    arghs=sub(r"^\(\^", r"(?<=;)(", arghs) # ^ matches semicolon before field 
    arghs=sub(r"\$\)$", r"(?=;))", arghs)  # $ matches semicolon after field 

    # s is a search regex for field 2 (name) based on the command line arguments
    s=r"""^
        (?P<hex>[^;]*);             # first field is hexadecimal codepoint
        (?P<name>[^;]*"""+arghs+"""[^;]*); # field 2 (charactername) matches?
        (?P<category>[^;]*);        # third field is general category 
        ([^;]*;){7}                 # skip next 7 fields
        (?P<alias>[^;]*)            # field 11 is comment/alias
        (;[^;]*){4}$                # line ends with four more fields
    """

    # r is a search regex for field 11 (alias)
    r=r"""^
        (?P<hextwo>[^;]*);            # first field is hexadecimal codepoint
        (?P<desctwo>[^;]*);           # second field is charactername
        (?P<categorytwo>[^;]*);       # third field is general category 
        ([^;]*;){7}                   # skip next 7 fields
        (?P<aliastwo>[^;]*("""+arghs+""")[^;]*) # field 11 (alias) matches?
        (;[^;]*){4}$                  # line ends with four more fields
    """

    s=s+"|"+r                   # Search for either name or alias
    s="(?mix)"+s                # multiline, case insensitive, verbose

    debugprint("Complete search regex is " + s)

    return s

def makeregexcodepoint(cp):
    "Make a regular expression to search for a hexadecimal codepoint"

    # User specified a codepoint, e.g., "U+23fb" 

    # Normalize whatever they put in to "23FB"
    cp=cp.lstrip("Uu+0Xx").upper().zfill(4)

    # s is a search regex for field 1 (hexadecimal)
    s=r"""^
        (?P<hex>"""+cp+""");		#first field is hex codepoint
        (?P<name>[^;]*);		# second field is charactername
        (?P<category>[^;]*);		# third field is category
        ([^;]*;){7}			# skip next 7 fields
        (?P<alias>[^;]*)            	# field 11 is comment/alias
    """
    s="(?mix)"+s                     # multiline, case insensitive, verbose
    return(s)



def rangeexpansion(oldargv):
    """Look for ranges "a..z" in oldargv[] and expand by inserting new elements.
    The new argv is returned to the caller. 

    0..7 	-->	0 1 2 3 4 5 6 7
    abc0..7 	--> 	abc0 abc1 abc2 abc3 abc4 abc5 abc6 abc7
    23b8..f	-->	23b8 23b9 23ba 23bb 23bc 23bd 23be 23bf

    Notes:

    * Does check for and correctly ignores prefix of U+ or 0x.
    * Should check for invalid ranges and ignore them instead of barfing.

    Design notes:

    * Although similar to shell brace expansion, and ugrep even
      accepts braces, we never suggest to the user to try that. The
      problem is that shell brace expansion is decimal, whereas ugrep
      is working in hexadecimal.

      ugrep '23{01..10}'  -> sixteen characters, cumbersome.
      ugrep  23{01..10}   -> ten characters sometimes (e.g., using bash)
      ugrep 2301..10	  -> always sixteen characters (recommended).

    * In Bash, if start or end begin with a "0", then it zfills to
      that width. For this program, the 0 is optional as it always
      uses the largest width of the two ends E.g., 23{0..ff} -> 2300, 2301,...

      There is no confusion without braces: 230..ff -> 230, 231, ... 
    """

    s=r"""(?mix)
	  (?P<prefix>[^{]*)
	  {?                   # Literal open curly brace (optional)
	  (U\+?|0?x)?
    	  (?P<start>.*)
	  \.\.                 # Literal two periods. MANDATORY.
	  (U\+?|0?x)?
	  (?P<end>.*)
	  }?                   # Literal close curly brace (optional)
	  (?P<suffix>[^}]*)
    """
    s=compile(s)
    newargv=[]

    for arg in oldargv:
        m=search(s, arg)
        if not m:
            newargv.append(arg)
        else:
            debugprint("Doing range expansion on " + arg)
            g=m.groupdict()
            prefix=g["prefix"]
            start=g["start"].strip("{}") # Python doesn't do lazy regexps?
            end=g["end"].strip("{}")     # So, we kludge this way.

            if start == "":
                # They left off the braces: 2390..f instead of 239{0..f}
                start=prefix
                end=prefix[:-len(end)]+end
                prefix=""
                
            debugprint("Found range from " + start + " to " + end)
            z=max(len(start), len(end))
            start=int(start, 16)
            end=int(end, 16)

            for i in range(start, end+1):
                hexits=hex(i)[2:].zfill(z)
                newargv.append( prefix + hexits + g["suffix"] )
    return(newargv)


def eprint(*args, **kwargs):
    "Print to stderr"
    print(*args, file=stderr, **kwargs)

def err(*args, **kwargs):
    "Print to stderr with program name prefixed"
    eprint(basename(argv[0]) + ": ", end='')
    eprint(*args, **kwargs)

def debugprint(*args, **kwargs):
    "If debug var is True, print to stderr with progname prefix"
    if (debug):
        err(*args, **kwargs)

def cleanup():
    if isatty(2):
        termios.tcdrain(2) 		# Wait for stderr to be printed
    if isatty(1):
        termios.tcflush(1, termios.TCOFLUSH) 	# Discard stdout
    esc=chr(0x1b)
    eprint(esc+"\\", end='')		# String Terminator for sixels (ST)
    eprint(esc+"#5", end='')		# Single width line (DECSWL)
    eprint("\r" + esc + "[J", end='')	# Erase to end of display (ED)

######################################################################

import atexit
atexit.register(cleanup)        	# When exiting, cleanup sixels


# VT340 is Latin-1 ISO8859-1 encoding.
# Python3 defaults to dying horribly on simple things like print('\u2020')
import sys
if sys.stdout:
    sys.stdout.reconfigure(errors='replace') 	# Print a ? instead of dying.


### Run the main routine
try:
    main()
except BrokenPipeError:
    # Ignore non-error errors. For example: 'ugrep -w pi | head'
    sys.stdout = None;
    cleanup()
except KeyboardInterrupt:		# Catch ^C
    cleanup()

atexit.unregister(cleanup)      # Normal exit, no need to cleanup.

debugprint("Normal exit")

# Implementation notes:

# This is a rewrite of b9's AWK ugrep in Python. While AWK makes a lot
# more sense for what this program does (comparing fields based on
# regexps), a rewrite was necessary because GNU awk, while plenty
# powerful, uses \y for word edges instead of \b and that was bugging
# me. Gawk does this for backwards compatibility with historic AWK,
# which is all well and good, but gawk has no way to disable it for
# new scripts.
#
# Switching to Python did have the benefit of allowing more powerful
# Perl-like regexes (not that anyone has requested that).
# 
# One downside is that I needed a huge hairy regex to simply search
# only in a certain field of each line. Maybe there's some Pythonic
# way to do it, but it's not obvious. Perhaps a 2D array?
#
# Also, I took for granted that awk let me use ^ and $ to search for
# the beginning and ending of fields instead of lines. I tried to
# reimplement that in Python, but it's not quite right as it only
# checks the first and last character. For example, ugrep "^x" works,
# but ugrep "(^x)" does not.


# Note: I do not use Python's `unicodedata` module because it is
# insufficient. It allows one to search by character name only if the
# precise name: `unicodedata.lookup("ROTATED HEAVY BLACK HEART BULLET")`.

